name: Update OpenCode

on:
  repository_dispatch:
    types:
      [
        opencode-release-detected,
      ]
  workflow_dispatch:

permissions:
  contents: write

jobs:
  update:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          # Use a token that can trigger other workflows if needed
          token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - name: Setup Nix
        uses: DeterminateSystems/nix-installer-action@main

      - name: Install nix-update
        run: nix profile add github:Mic92/nix-update

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Step 1 - Update Version String
        run: |
          echo "▶ Checking for new version..."
          nix-update --flake opencode --version=auto || true
          VERSION=$(grep -oP 'version = "\K[^"]+' package.nix | head -1)
          echo "VERSION=$VERSION" >> $GITHUB_ENV
          echo "✓ Version is set to: $VERSION"

      - name: Step 2 - Unconditionally Reset All Hashes
        run: |
          echo "▶ Unconditionally resetting all hash types to dummy values..."
          DUMMY_A="sha256-AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
          DUMMY_B="sha256-BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB="
          DUMMY_C="sha256-CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC="
          sed -i -E "s/(hash = \").*(\")/\1$DUMMY_A\2/" package.nix
          sed -i -E "s/(vendorHash = \").*(\")/\1$DUMMY_C\2/" package.nix
          sed -i -E "s/(x86_64-linux = \").*(\")/\1$DUMMY_B\2/" package.nix
          sed -i -E "s/(aarch64-linux = \").*(\")/\1$DUMMY_B\2/" package.nix
          echo "✓ Dummy hashes have been set."

      - name: Step 3 - Verification Loop for Native Arch x86_64-linux
        run: |
          echo "▶ Starting Verification Loop for Native (x86_64-linux)"
          MAX_ATTEMPTS=4
          for ATTEMPT in $(seq 1 $MAX_ATTEMPTS); do
            echo "---"
            echo "Native Build Attempt $ATTEMPT/$MAX_ATTEMPTS"

            LOG=$(mktemp)
            set -o pipefail
            if nix build .#opencode -L 2> >(tee "$LOG" >&2); then
              echo "✓ Native build successful! All x86_64 hashes are verified."
              exit 0
            fi
            BUILD_OUTPUT=$(cat "$LOG")

            EXPECTED_FAIL=0
            # 1) Normal top-level hash mismatch is always repairable.
            echo "$BUILD_OUTPUT" | grep -q 'hash mismatch' && EXPECTED_FAIL=1

            # 2) Vendor FOD missing $out is repairable only if vendor dummy remains.
            if grep -q 'vendorHash = "sha256-CCCC' package.nix; then
              if echo "$BUILD_OUTPUT" | grep -q '/nix/store/.*-go-modules\.drv' && \
                 echo "$BUILD_OUTPUT" | grep -q 'No such file or directory'; then
                EXPECTED_FAIL=1
              fi
            fi

            if [ $EXPECTED_FAIL -eq 0 ]; then
              echo "✗ Non-repairable failure:"
              echo "$BUILD_OUTPUT"
              exit 1
            fi

            echo "Build failed in a fixable way. Extracting correct hash…"

            # Try top-level got first.
            CORRECT_HASH=$(echo "$BUILD_OUTPUT" | grep -oP 'got:\s+\Ksha256-[A-Za-z0-9+/=]+' | head -1)

            # Fallback: get vendor 'got:' from go-modules sub-derivation log.
            if [ -z "$CORRECT_HASH" ]; then
              SUBDRV=$(echo "$BUILD_OUTPUT" | grep -o '/nix/store/[^ ]*-go-modules\.drv' | head -1)
              if [ -n "$SUBDRV" ]; then
                MODLOG=$(nix log "$SUBDRV" 2>/dev/null || true)
                CORRECT_HASH=$(echo "$MODLOG" | grep -oP 'got:\s+\Ksha256-[A-Za-z0-9+/=]+' | head -1)
              fi
            fi

            if [ -z "$CORRECT_HASH" ]; then
              echo "✗ No usable 'got:' hash found; tail of go-modules log (if any):"
              [ -n "$MODLOG" ] && echo "$MODLOG" | tail -200 || true
              exit 1
            fi

            echo "→ Nix expects hash: $CORRECT_HASH"

            # Replace placeholders in strict order to minimize cross-matches.
            if grep -q 'hash = "sha256-AAAA' package.nix; then
              sed -i "s|sha256-AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=|$CORRECT_HASH|" package.nix
            elif grep -q 'vendorHash = "sha256-CCCC' package.nix; then
              sed -i -E "s|(vendorHash = \")sha256-CCCC[^\"]*(\")|\1$CORRECT_HASH\2|" package.nix
            elif grep -q 'x86_64-linux = "sha256-BBBB' package.nix; then
              sed -i -E "s|(x86_64-linux = \")sha256-BBBB[^\"]*(\")|\1$CORRECT_HASH\2|" package.nix
            else
              echo "✗ Got a hash but nothing to replace."
              exit 1
            fi
          done

          echo "✗ Failed to fix native hashes after $MAX_ATTEMPTS attempts."
          exit 1


      - name: Step 4 - One-Shot Discovery for Emulated Arch aarch64-linux
        run: |
          echo "▶ Starting One-Shot Discovery for Emulated (aarch64-linux) hash"
          BUILD_OUTPUT=$(nix build .#opencode --system aarch64-linux -L 2>&1) || true
          if ! echo "$BUILD_OUTPUT" | grep -q "hash mismatch"; then echo "✓ Emulated build did not fail with a hash mismatch. Assuming aarch64 hash is already correct."; exit 0; fi
          echo "Build failed as expected. Extracting the correct hash..."
          CORRECT_HASH=$(echo "$BUILD_OUTPUT" | grep -oP 'got:\s+\Ksha256-[A-Za-z0-9+/=]+' | head -1)
          if [ -z "$CORRECT_HASH" ]; then echo "✗ Emulated build failed for a reason other than hash mismatch."; echo "$BUILD_OUTPUT"; exit 1; fi
          echo "→ Nix expects hash: $CORRECT_HASH"
          echo "  Replacing aarch64-linux outputHash..."
          sed -i -E "s|(aarch64-linux = \")sha256-BBBB[^\"]*(\")|\1$CORRECT_HASH\2|" package.nix
          echo "✓ aarch64 hash discovered and written successfully."

      - name: Step 5 - Commit and Push if Changes Exist
        run: |
          echo "▶ Checking for changes to package.nix..."
          # Use `git diff --quiet` to see if the file has actually changed.
          if ! git diff --quiet package.nix; then
            echo "✓ Changes detected. Committing and pushing..."
            git add package.nix
            git commit -m "Update OpenCode to ${{ env.VERSION }}" -m "Automated hash verification for x86_64 and aarch64"
            git tag -f "v${{ env.VERSION }}"

            echo "▶ Synchronizing with remote branch before pushing..."
            # Pull with rebase to handle potential race conditions where the remote branch was updated
            # during the workflow run. This avoids merge conflicts for this linear update.
            git pull origin master --rebase

            echo "▶ Pushing changes to remote..."
            git push origin HEAD:master
            git push -f origin "v${{ env.VERSION }}"
          else
            echo "✓ No changes to package.nix. Repository is already up-to-date."
          fi
